# es6 class
## 简介
### 类的由来
（1）class 就是函数 typeof class === 'function'
（2）class内部的方法相当于在xxx.prototype上定义
（3）class 的prototype.constructor直接指向类本身，与es5一致
（4）class内定义的方法不可枚举，与es5不一致，可以通过object.getOwnPropertyNames获取内部方法
### constructor方法
（1）new时会调用，一个类必须有constructor，会默认添加空的constructor
（2）默认返回实例对象（this），也可以显式返回其他对象
（3）类必须使用new调用否则报错（原因：）
### 类的实例
（1）实例属性除非显式定义在其自身上，否则都是定义在原型上
（2）类的所有实例共享一个原型对象
（3__proto__是各个厂商定义的私有属性，要减少使用，以免造成环境依赖，可以通过object.getPrototypeOf获取实例对象的原型，然后再到原型上添加属性/方法（但是尽量避免因为添加后会改变类的原始定义，影响所有实例）
### 存值函数与取值函数
（1）存值函数与取值函数是设置在属性的Descriptor对象上，与es5一致
### 属性表达式
（1）类的属性名可以使用表达式
### class表达式
（1）与函数一样类也可以使用表达式定义，但是外部只能使用表达式的值调用，class名只能class内部使用，如果class内部没用到类名表达式定义时可以省略
（2）表达式定义class可以写出立即执行的class
### 注意点
（1）严格模式：类和模块的内部默认严格模式
（2）不存在提升：与es5完全不同（原因与继承相关，必须保证子类在父类之后定义）
（3）name属性：返回紧跟在class后面的类名
（4）Generator方法：类内部方法加了*号就是generator函数
（5）this指向：默认指向类的实例，但是一旦单独使用该方法很可能会报错；可以在构造函数中绑定this；也可以使用箭头函数；还可以使用Proxy，获取方法的时候自动绑定this

## 静态方法
（1）加上static关键字就不会被实例继承只能类调用
（2）静态方法中的this指向类而不是实例,静态方法与非静态方法可以重名
（3）父类的静态方法可以被子类继承
（4）静态方法可以从super上调用

## 实例属性的新写法
（1）可以定义在constructor的this上也可以定义在class的最顶层

## 静态属性
（1）指的是class本身的属性，而不是this上的实例属性
（2）目前只能在类外部加静态属性，有提案在class静态属性前加static(试了一下好像支持了)，新写法将相关代码放一起更符合规范且显式声明语意更好

## 私有方法和私有属性
### 现有的解决方案
（1）私有属性和方法是只能在类内部访问的属性和方法（与静态方法的不同点在于私有方法可以访问实例属性与方法，但是不能访问静态方法与属性）
（2）es6不提供，可以使用_xxx自觉限制区分，不保险，实际还是可访问
（3）另一种实现方式是将私有方法移出class，然后调用的时候指定this为当前类
（4）还可以利用Symbol值的唯一性，一般情况无法获取到他们，因此达到私有属性与方法的效果（Reflect.ownKeys还是能拿到）
### 私有变量提案
（1）在属性或方法前加#表示（方法貌似还不支持）
（2）私有属性不限制于从this引用，只要在类的内部，实例也可以引用私有属性
（3）私有属性和方法的前面可以加上static关键字，表示这是一个静态的私有属性或方法

### in 运算符
（1）可以用来判断私有属性是否存在（使用try...catch可读性太差）,判断时in只能在私有属性定义类的内部
（2）子类从父类继承的私有属性，in运算符也生效（对于Object.create和Object,setPrototypeOf形成的继承无效，因为不会传递私有属性）

### new.target 属性
（1）一般用于在构造函数中，返回new命令作用于的那个构造函数，如果构造函数不是通过new命令或者Reflect.constrouct调用的，会返回undefined，可用于确定构造函数的调用方式
（2）子类继承父类时，new.target会返回子类（可用于写出不能独立使用，必须继承之后才能使用的类）
（3）函数外部调用会报错(实际没有)

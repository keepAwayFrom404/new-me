# es6 的基本语法
## 简介
### 类的由来
（1）class 就是函数 typeof class === 'function'
（2）class内部的方法相当于在xxx.prototype上定义
（3）class 的prototype.constructor直接指向类本身，与es5一致
（4）class内定义的方法不可枚举，与es5不一致，可以通过object.getOwnPropertyNames获取内部方法
### constructor方法
（1）new时会调用，一个类必须有constructor，会默认添加空的constructor
（2）默认返回实例对象（this），也可以显式返回其他对象
（3）类必须使用new调用否则报错（原因：）
### 类的实例
（1）实例属性除非显式定义在其自身上，否则都是定义在原型上
（2）类的所有实例共享一个原型对象
（3__proto__是各个厂商定义的私有属性，要减少使用，以免造成环境依赖，可以通过object.getPrototypeOf获取实例对象的原型，然后再到原型上添加属性/方法（但是尽量避免因为添加后会改变类的原始定义，影响所有实例）
### 存值函数与取值函数
（1）存值函数与取值函数是设置在属性的Descriptor对象上，与es5一致
### 属性表达式
（1）类的属性名可以使用表达式
### class表达式
（1）与函数一样类也可以使用表达式定义，但是外部只能使用表达式的值调用，class名只能class内部使用，如果class内部没用到类名表达式定义时可以省略
（2）表达式定义class可以写出立即执行的class
### 注意点
（1）严格模式：类和模块的内部默认严格模式
（2）不存在提升：与es5完全不同（原因与继承相关，必须保证子类在父类之后定义）
（3）name属性：返回紧跟在class后面的类名
（4）Generator方法：类内部方法加了*号就是generator函数
（5）this指向：默认指向类的实例，但是一旦单独使用该方法很可能会报错；可以在构造函数中绑定this；也可以使用箭头函数；还可以使用Proxy，获取方法的时候自动绑定this

## 静态方法
（1）加上static关键字就不会被实例继承只能类调用
（2）静态方法中的this指向类而不是实例,静态方法与非静态方法可以重名
（3）父类的静态方法可以被子类继承
（4）静态方法可以从super上调用

## 实例属性的新写法
（1）可以定义在constructor的this上也可以定义在class的最顶层

## 静态属性
（1）指的是class本身的属性，而不是this上的实例属性
（2）目前只能在类外部加静态属性，有提案在class静态属性前加static(试了一下好像支持了)，新写法将相关代码放一起更符合规范且显式声明语意更好

## 私有方法和私有属性
### 现有的解决方案
（1）私有属性和方法是只能在类内部访问的属性和方法（与静态方法的不同点在于私有方法可以访问实例属性与方法，但是不能访问静态方法与属性）
（2）es6不提供，可以使用_xxx自觉限制区分，不保险，实际还是可访问
（3）另一种实现方式是将私有方法移出class，然后调用的时候指定this为当前类
（4）还可以利用Symbol值的唯一性，一般情况无法获取到他们，因此达到私有属性与方法的效果（Reflect.ownKeys还是能拿到）
### 私有变量提案
（1）在属性或方法前加#表示（方法貌似还不支持）
（2）私有属性不限制于从this引用，只要在类的内部，实例也可以引用私有属性
（3）私有属性和方法的前面可以加上static关键字，表示这是一个静态的私有属性或方法

### in 运算符
（1）可以用来判断私有属性是否存在（使用try...catch可读性太差）,判断时in只能在私有属性定义类的内部
（2）子类从父类继承的私有属性，in运算符也生效（对于Object.create和Object,setPrototypeOf形成的继承无效，因为不会传递私有属性）

### new.target 属性
（1）一般用于在构造函数中，返回new命令作用于的那个构造函数，如果构造函数不是通过new命令或者Reflect.constrouct调用的，会返回undefined，可用于确定构造函数的调用方式
（2）子类继承父类时，new.target会返回子类（可用于写出不能独立使用，必须继承之后才能使用的类）
（3）函数外部调用会报错(实际没有)

# class的继承
## 简介
（1）es5的继承是先创建子类的实例对象，再将父类方法添加到this（parent.apply(this)）；es6是先将父类实例对象的属性和方法加到this上面（通过super方法），然后再用子类的构造函数修改this
（2）如果没有定义构造函数，默认会添加constructor并super调用
（3）子类构造函数中，只有调用了super之后才能使用this，否则报错，因为子类的构建基于父类的实例，只有super能调用父类的实例
（4）父类的静态方法也会被子类继承
## Object.getPrototypeOf
（1）可用来从子类获取父类，可用于判断一个类是否继承了另一个类（es5也能使用吗？）
## super 关键字
（1）既可以当作函数使用也可以当作对象使用
（2）作为函数调用时，代表父类的构造函数（返回的是子类的实例，super内部的this为子类实例）
（3）作为函数使用只能在构造函数中，否则报错
（4）super作为对象在普通方法中指向父类的原型对象，在静态方法中指向父类
（5）定义在父类实例上的方法或属性无法通过super调用
（6）在子类通过super调用方法this指向子类实例(实际调用call绑定的this)
（7）通过super对某个属性赋值，赋值的属性会变成子类的实例属性
（8）静态方法中通过super调用子类的方法，this指向当前子类
（9）使用super需要显式指定作为函数还是对象否则会报错
（10）可以在任意一个对象中使用super关键字

## 类的 prototype 属性和 __proto__ 属性
（1）子类的__proto__表示构造函数的继承，总是指向父类
（2）子类的prototype属性的__proto__表示方法的继承，总是指向父类的prototype
（3）作为对象子类的原型是父类，作为构造函数，子类的原型对象是父类的原型对象的实例
（4）实例的__proto__属性：子类实例的原型的原型是父类实例的原型（就是父类的prototype）,因此可以通过子类实例的.__proto__.__proto__修改父类实例的行为（因为修改了父类的prototype）

## 原生构造函数的继承
（1）之前原生构造函数不可继承，无法创建子类(子类无法获取原生构造函数的内部属性，原生构造函数的this无法绑定使用apply也不行，也因为es5是先创建子类再将父类的属性添加到子类上，但内部属性无法获取)
（2）es6允许继承原生构造函数，因为它先创建父类的实例对象（此时已经有原生函数的属性与方法了）然后再用子类的构造函数修饰this
（3）es6的extends关键字不仅可以继承类还可以继承原生构造函数，因此可以在原生数据结构的基础上定义自己的数据结构
（4）es6改变了Object构造函数的行为，一旦发现Object不是通过new调用，构造函数就会忽略参数

## mixin 模式的实现
（1）将多个对象合成一个新对象，新对象具有各个组成成员的接口